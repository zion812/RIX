package com.rio.rostry.core.data.repository

import com.google.firebase.firestore.FirebaseFirestore
import com.rio.rostry.core.data.service.UserValidationService
import com.rio.rostry.core.database.dao.FowlDao
import com.rio.rostry.core.database.entities.FowlEntity
import com.rio.rostry.core.network.NetworkStateManager
import kotlinx.coroutines.tasks.await
import java.util.*
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Breeding repository implementation for fowl breeding operations
 */
@Singleton
class BreedingRepositoryImpl @Inject constructor(
    private val fowlDao: FowlDao,
    private val userValidationService: UserValidationService,
    private val firestore: FirebaseFirestore,
    private val networkStateManager: NetworkStateManager
) {
    
    /**
     * Record a breeding event
     */
    suspend fun recordBreeding(
        maleId: String,
        femaleId: String,
        breederId: String,
        expectedHatchDate: Date? = null
    ): Result<String> {
        return try {
            // Validate breeder
            val validation = userValidationService.validateUserExists(breederId)
            if (!validation.isValid) {
                return Result.failure(Exception("Invalid breeder"))
            }
            
            // Validate parent fowls exist and belong to breeder
            val male = fowlDao.getById(maleId)
            val female = fowlDao.getById(femaleId)
            
            if (male == null || female == null) {
                return Result.failure(Exception("Parent fowls not found"))
            }
            
            if (male.ownerId != breederId || female.ownerId != breederId) {
                return Result.failure(Exception("Breeder must own both parent fowls"))
            }
            
            // Create breeding record
            val breedingId = UUID.randomUUID().toString()
            val breedingData = mapOf(
                "id" to breedingId,
                "maleId" to maleId,
                "femaleId" to femaleId,
                "breederId" to breederId,
                "breedingDate" to Date(),
                "expectedHatchDate" to expectedHatchDate,
                "status" to "ACTIVE",
                "createdAt" to Date(),
                "updatedAt" to Date()
            )
            
            // Save to server if online
            if (networkStateManager.isConnected()) {
                firestore.collection("breeding_records")
                    .document(breedingId)
                    .set(breedingData)
                    .await()
            }
            
            Result.success(breedingId)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Register offspring from a breeding
     */
    suspend fun registerOffspring(
        breedingId: String,
        offspringData: Map<String, Any>
    ): Result<String> {
        return try {
            // Get breeding record
            val breedingDoc = if (networkStateManager.isConnected()) {
                firestore.collection("breeding_records")
                    .document(breedingId)
                    .get()
                    .await()
            } else {
                return Result.failure(Exception("Breeding record not available offline"))
            }
            
            if (!breedingDoc.exists()) {
                return Result.failure(Exception("Breeding record not found"))
            }
            
            val maleId = breedingDoc.getString("maleId")
            val femaleId = breedingDoc.getString("femaleId")
            val breederId = breedingDoc.getString("breederId")
            
            if (maleId == null || femaleId == null || breederId == null) {
                return Result.failure(Exception("Invalid breeding record"))
            }
            
            // Create offspring fowl
            val offspringId = UUID.randomUUID().toString()
            val offspring = FowlEntity(
                id = offspringId,
                name = offspringData["name"] as? String ?: "",
                breed = offspringData["breed"] as? String ?: "Mixed",
                ownerId = breederId,
                parentMaleId = maleId,
                parentFemaleId = femaleId,
                birthDate = offspringData["birthDate"] as? Date ?: Date(),
                gender = offspringData["gender"] as? String ?: "Unknown",
                color = offspringData["color"] as? String,
                description = offspringData["description"] as? String,
                createdAt = Date(),
                updatedAt = Date(),
                isSynced = false
            )
            
            // Save offspring locally
            fowlDao.insert(offspring)
            
            // Update breeding record
            if (networkStateManager.isConnected()) {
                firestore.collection("breeding_records")
                    .document(breedingId)
                    .update(mapOf(
                        "offspringIds" to com.google.firebase.firestore.FieldValue.arrayUnion(offspringId),
                        "status" to "COMPLETED",
                        "updatedAt" to Date()
                    ))
                    .await()
            }
            
            Result.success(offspringId)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Get breeding history for a fowl
     */
    suspend fun getBreedingHistory(fowlId: String): Result<List<Map<String, Any>>> {
        return try {
            if (!networkStateManager.isConnected()) {
                return Result.failure(Exception("Breeding history not available offline"))
            }
            
            val querySnapshot = firestore.collection("breeding_records")
                .whereEqualTo("maleId", fowlId)
                .get()
                .await()
            
            val femaleQuerySnapshot = firestore.collection("breeding_records")
                .whereEqualTo("femaleId", fowlId)
                .get()
                .await()
            
            val breedingRecords = mutableListOf<Map<String, Any>>()
            
            querySnapshot.documents.forEach { doc ->
                breedingRecords.add(doc.data ?: emptyMap())
            }
            
            femaleQuerySnapshot.documents.forEach { doc ->
                breedingRecords.add(doc.data ?: emptyMap())
            }
            
            Result.success(breedingRecords)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Get family tree for a fowl
     */
    suspend fun getFamilyTree(fowlId: String, generations: Int = 3): Result<Map<String, Any>> {
        return try {
            val fowl = fowlDao.getById(fowlId)
                ?: return Result.failure(Exception("Fowl not found"))
            
            val familyTree = mutableMapOf<String, Any>()
            familyTree["fowl"] = fowl
            
            // Get parents
            if (fowl.parentMaleId != null) {
                val father = fowlDao.getById(fowl.parentMaleId)
                if (father != null) {
                    familyTree["father"] = father
                    
                    // Recursively get grandparents if more generations requested
                    if (generations > 1) {
                        val fatherTree = getFamilyTree(father.id, generations - 1)
                        if (fatherTree.isSuccess) {
                            familyTree["fatherTree"] = fatherTree.getOrNull() ?: emptyMap<String, Any>()
                        }
                    }
                }
            }
            
            if (fowl.parentFemaleId != null) {
                val mother = fowlDao.getById(fowl.parentFemaleId)
                if (mother != null) {
                    familyTree["mother"] = mother
                    
                    // Recursively get grandparents if more generations requested
                    if (generations > 1) {
                        val motherTree = getFamilyTree(mother.id, generations - 1)
                        if (motherTree.isSuccess) {
                            familyTree["motherTree"] = motherTree.getOrNull() ?: emptyMap<String, Any>()
                        }
                    }
                }
            }
            
            // Get offspring
            val offspring = fowlDao.getOffspringByParent(fowlId)
            if (offspring.isNotEmpty()) {
                familyTree["offspring"] = offspring
            }
            
            Result.success(familyTree)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
