package com.rio.rostry.core.data.repository

import com.google.firebase.firestore.FirebaseFirestore
import com.rio.rostry.core.database.dao.NotificationDao
import com.rio.rostry.core.database.dao.NotificationPreferenceDao
import com.rio.rostry.core.database.entities.NotificationEntity
import com.rio.rostry.core.database.entities.NotificationPreferenceEntity
import com.rio.rostry.core.network.NetworkStateManager
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.tasks.await
import java.util.*
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Notification repository implementation with offline-first capabilities
 */
@Singleton
class NotificationRepositoryImpl @Inject constructor(
    private val notificationDao: NotificationDao,
    private val notificationPreferenceDao: NotificationPreferenceDao,
    private val firestore: FirebaseFirestore,
    private val networkStateManager: NetworkStateManager
) {
    
    /**
     * Get notifications for a user
     */
    fun getNotifications(userId: String): Flow<List<NotificationEntity>> {
        return notificationDao.observeNotificationsByUser(userId)
    }
    
    /**
     * Get unread notification count
     */
    fun getUnreadCount(userId: String): Flow<Int> {
        return notificationDao.observeUnreadCount(userId)
    }
    
    /**
     * Mark notification as read
     */
    suspend fun markAsRead(notificationId: String): Result<Unit> {
        return try {
            notificationDao.markAsRead(notificationId, Date())
            
            if (networkStateManager.isConnected()) {
                firestore.collection("notifications")
                    .document(notificationId)
                    .update(mapOf(
                        "isRead" to true,
                        "readAt" to Date()
                    ))
                    .await()
            }
            
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Mark all notifications as read for a user
     */
    suspend fun markAllAsRead(userId: String): Result<Unit> {
        return try {
            notificationDao.markAllAsRead(userId, Date())
            
            if (networkStateManager.isConnected()) {
                // Update all unread notifications on server
                val unreadNotifications = notificationDao.getUnreadNotifications(userId)
                for (notification in unreadNotifications) {
                    firestore.collection("notifications")
                        .document(notification.id)
                        .update(mapOf(
                            "isRead" to true,
                            "readAt" to Date()
                        ))
                        .await()
                }
            }
            
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Create a new notification
     */
    suspend fun createNotification(
        userId: String,
        title: String,
        message: String,
        type: String,
        data: String? = null,
        imageUrl: String? = null
    ): Result<String> {
        return try {
            val notificationId = UUID.randomUUID().toString()
            val notification = NotificationEntity(
                id = notificationId,
                userId = userId,
                type = type,
                title = title,
                message = message,
                data = data,
                imageUrl = imageUrl,
                isRead = false,
                priority = "normal",
                category = "general",
                createdAt = Date(),
                updatedAt = Date(),
                isSynced = false
            )
            
            // Save locally first
            notificationDao.insert(notification)
            
            // Sync to server if online
            if (networkStateManager.isConnected()) {
                try {
                    syncNotificationToServer(notification)
                    notificationDao.markAsSynced(notificationId)
                } catch (e: Exception) {
                    // Will be synced later
                }
            }
            
            Result.success(notificationId)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Delete notification
     */
    suspend fun deleteNotification(notificationId: String): Result<Unit> {
        return try {
            notificationDao.delete(notificationId)
            
            if (networkStateManager.isConnected()) {
                firestore.collection("notifications")
                    .document(notificationId)
                    .delete()
                    .await()
            }
            
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Get notification preferences for a user
     */
    suspend fun getNotificationPreferences(userId: String): NotificationPreferenceEntity? {
        return notificationPreferenceDao.getPreferences(userId)
    }
    
    /**
     * Update notification preferences
     */
    suspend fun updateNotificationPreferences(
        userId: String,
        preferences: NotificationPreferenceEntity
    ): Result<Unit> {
        return try {
            notificationPreferenceDao.insert(preferences)
            
            if (networkStateManager.isConnected()) {
                val preferencesData = mapOf(
                    "marketplaceNotifications" to preferences.marketplaceNotifications,
                    "transferNotifications" to preferences.transferNotifications,
                    "communicationNotifications" to preferences.communicationNotifications,
                    "breedingNotifications" to preferences.breedingNotifications,
                    "paymentNotifications" to preferences.paymentNotifications,
                    "systemNotifications" to preferences.systemNotifications,
                    "quietHoursEnabled" to preferences.quietHoursEnabled,
                    "quietHoursStart" to preferences.quietHoursStart,
                    "quietHoursEnd" to preferences.quietHoursEnd,
                    "soundEnabled" to preferences.soundEnabled,
                    "vibrationEnabled" to preferences.vibrationEnabled,
                    "updatedAt" to Date()
                )
                
                firestore.collection("notification_preferences")
                    .document(userId)
                    .set(preferencesData)
                    .await()
            }
            
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Sync notification to server
     */
    private suspend fun syncNotificationToServer(notification: NotificationEntity) {
        val notificationData = mapOf(
            "userId" to notification.userId,
            "type" to notification.type,
            "title" to notification.title,
            "message" to notification.message,
            "data" to notification.data,
            "imageUrl" to notification.imageUrl,
            "isRead" to notification.isRead,
            "priority" to notification.priority,
            "category" to notification.category,
            "createdAt" to notification.createdAt,
            "updatedAt" to notification.updatedAt
        ).filterValues { it != null }
        
        firestore.collection("notifications")
            .document(notification.id)
            .set(notificationData)
            .await()
    }
    
    /**
     * Sync offline changes
     */
    suspend fun syncOfflineChanges(): Result<Unit> {
        return try {
            if (!networkStateManager.isConnected()) {
                return Result.failure(Exception("No network connection"))
            }
            
            val unsyncedNotifications = notificationDao.getUnsyncedNotifications()
            for (notification in unsyncedNotifications) {
                try {
                    syncNotificationToServer(notification)
                    notificationDao.markAsSynced(notification.id)
                } catch (e: Exception) {
                    continue
                }
            }
            
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
